<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>Bayberry - Complement Test Frameworks</title>
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushJava.js"></script>
	<link type="text/css" rel="stylesheet" href="styles/shCore.css"/>
	<link type="text/css" rel="stylesheet" href="styles/shThemeDefault.css"/>
	<script type="text/javascript">
		SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
		SyntaxHighlighter.all();
	</script>
</head>
<body>
	<h1>Bayberry</h1>
	<p>Goal of this project is to complement test frameworks for projects using Guice. It has three major features: </p>
	<ol>
	<li><a href="#dependency_injection">Dependency Injection</a></li>
	<li><a href="#fixture_injection">Fixture Injection</a></li>
	<li><a href="#helper_injection">Helper Injection</a></li>
	</ol>
	<p>Download: <a href="http://taowen.github.com/bayberry/repository/org/bayberry/bayberry/0.4-final/bayberry-0.4-final.jar">bayberry-0.4-final.jar</a></p>
	<p>Maven Repository: <a href="http://taowen.github.com/bayberry/repository">http://taowen.github.com/bayberry/repository</a></p>
	<p>Github Project: <a href="http://github.com/taowen/bayberry/tree/master">http://github.com/taowen/bayberry/tree/master</a></p>
	<a name="dependency_injection"><h2>Dependency Injection</h2></a>
	<p>Bridge the gap between Guice and test frameworks. Currently, only JUnit4 is supported, but the core implementation is separated from test framework specific API. So it would be easy to add support for other test frameworks, such as JUnit3 or TestNG.</p>
	<h3>Basic Usage</h3>
	<pre class="brush: java">
	@ConfiguredWith({SomeModule.class, AnotherModule.class})
	public static class SomeTest extends UsingBayberry {
		@Inject
		SomeDependency someDependency;
	}</pre>
	<p>This is the most basic way to use Bayberry. @ConfiguredWith take a list of module classes to create the injector for test. Module class must have a default constructor, if module creation requires special handling, you can use @Provides to provide module yourself which will be talked about later.</p>
	<h3>Customized Module Creation</h3>
	<pre class="brush: java">
	public static class SomeTest extends UsingBayberry {
		
		@Provides
		Module someModule() {
			return new SomeModule("some parameter");
		}
	}</pre>
	<p>When the module does not have a default constructor, you might want to create the module yourself. @Provides gives you a way to do that. Another motivation to create module yourself, is to control the count of instances of the module. Modules created by @ConfiguredWith will only has one instance. And Bayberry has a built-in Guice Injector (Which is a container for everything, so might be expensive to create) cache using the module as the key. So, you will always get the same injector by default. Using @Provides, you have a option to change this behavior by control the creation of the module instances.</p>
	<h3>Module Overriding</h3>
	<pre class="brush: java">
	@ConfiguredWith(SomeProdModule.class)
	@OverriddenBy(SomeTestModule.class)
	public class SomeTest extends UsingBayberry {
	}</pre>
	<p>In Guice 2.0, a feature of module overridden is available. Although in general, we should split modules into smaller modules to support flexible module composition to support different environment, instead of trying to override some bindings for a large monolic module. Anyway, it is always good have a option. @OverriddenBy is used to specify a list of modules overriding the modules configured either using @configuredWith or @Provides.</p>
	<h3>Inheritance</h3>
	<pre class="brush: java">
	@ConfiguredWith(SomeModule.class)
	public class AbstractTest extends UsingBayberry {
	}
	@ConfiguredWith(AnotherModule.class)
	@OverriddenBy(OverridingSomeModule.class)
	public class SomeTest extends AnotherTest {
	
		@Provides
		Module yetAnotherModule() {
			return new YetAnotherModule();
		}
	}</pre>
	<p>It is very common to extract out common test settings into parent class. Bayberry has full support for that. In the above example, the order of adding and overriding of modules will be: SomeModule -> AnotherModule -> YetAnotherModule -> OverridingSomeModule.</p>
	<a name="fixture_injection"><h2>Fixture Injection</h2></a>
	<p>It is a already a common sense to use dependency injection to promote a better design. We avoide using "new" operator whenever we could. But in our test cases, we still use "new" operator to create test data. When the test data creation is not as trival as three lines, not only the test is not readable, maintainable, but also the test data creation need to be duplicated between test cases. In rails, you can use YAML to create fixture sharing data between tests. Bayberry also supports fixture. Instead of using YAML, we think a fixture is just a object, so all we need is a "Provider" to provide the fixture. How to create the fixture and when to create it, is all upon the user's choice.</p>
	<h3>Fixture for Test</h3>
	<pre class="brush: java">
	public class SomeTest extends UsingBayberry {
	
		@Fixture(SomeFixtureProvider.class)
		String someFixture;
	
		public static class SomeFixtureProvider extends FixtureProvider {
		
			public Object getFixture() {
				return "Hello";
			}
		}
	}
	</pre>
	<p>This is most basic usage of fixture. You need some test data in the test, just add field and mark it with @Fixture specifying the "Provider" of it. Although we are extending from FixtureProvider in this case, but you can also just use simple Guice Provider instead. In real project, you can choose to persist the fixture using Hibernate, or you can actually loading the test data from some xml file.</p>
	<h3>Fixture for Fixture Provider</h3>
	<pre class="brush: java">
	public class SomeFixtureProvider extends FixtureProvider {
	
		@Fixture(AnotherFixtureProvider.class)
		String anothoerFixture;
		
		public Object getFixture() {
			return anotherFixture + " World";
		}
	}
	
	public class AnotherFixtureProvider extends FixtureProvider {
	
		public Object getFixture() {
			return "Hello";
		}
	}</pre>
	<p>Fixture provider itself can also require data injection. This is very powerful in real project. For example, Hibernate will not automically save tranisent object unless the relationship is marked as cascade. Using data injection for fixture provider, we can persist fixtures one by one, and compose them together. Instead of building a big object graph in one time and persist it in one time, which will not work unless all your domain model relationships is marked as cascade.</p>
	<h3>Scope</h3>
	<pre class="brush: java">
	@PerTest
	public class SomeFixtureProvider extends FixtureProvider {
	
		public Object getFixture() {
			return new Object();
		}
	}</pre>
	<p>Fixture can be scoped just like other dependencies. Built-in scope annotation @Singleton can be used, if the fixture is readonly. Or we can leave the fixture provider unscoped, which will create new instance everytime. Also, Bayberry provides a @PerTest scope, which will share same instance within a test method execution.</p>
	<a name="helper_injection"><h2>Helper Injection</h2></a>
	<p>Again, dependency injection is already common sense, but people still use static methods as test helpers. There are two drawbacks to use static test helper:</p>
	<ol>
	<li>Not extensible</li>
	<p>For example, static import assertThat can be convinent if all defined in same class. If there are two class defined two test helpers, both of them called assertThat, we have to rename one of them to static import, or we need to fully qualify it when invoking the helper.</p>
	<li>Can not reference context</li>
	<p>For example, test helper can not get database connection. It would be great, if the test helper is also created by Guice, so it has full reference to all kinds of contexts.</p>
	</ol>
	<h3>Fest Assert Helper</h3>
	<pre class="brush: java">
	public class SomeTest extends UsingBayberry {
		
		@Helper
		FestAssertHelper i;
		
		public void test() {
			i.assertThat("hello").isEqualTo("hello");
		}
	}</pre>
	<p>Fest-assert integration is built-in. Naming the test helper as "i" is just a syntax sugar.</p>	
</body>
</html>
